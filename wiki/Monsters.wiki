= amoeba =
{{{
Big amoeba:

C6 43 10 (03:16) C6 43 11 (00:17)  B8 (0A:19) 00 00 00 C6 43 12
(00:18) E8 DC EA FF FF 88 43  13 0F B6 43 13 6B F0 2E
C6 43 15 (02:21) C6 43 16 (00:22)  C6 43 14 (01:20) 66 C7 43 1C
(2D:28) 00 C6 43 20 (0F:32) 66 C7  43 21 (00:33) 00 C6 43 23 00
C6 43 1E 02 C6 43 1F 02  66 C7 43 24 17 00 C6 43
28 0F 66 C7 43 29 00 00  C6 43 2B 0A C6 43 26 05
C6 43 27 05 0F B6 43 10  C6 43 5C 08 EB 4C C6 43
10 02 C6 43 11 00 C6 43  12 00 C6 43 15 02 C6 43
16 00 C6 43 13 00 C6 43  14 00 66 C7 43 1C 2D 00

small amoeba:

C6 43 10 (02:16) C6 43 11 (00:17)  C6 43 12 (00:18) C6 43 15 (02:21)
C6 43 16 (00:22) C6 43 13 00  C6 43 14 00 66 C7 43 1C
2D 00 C6 43 20 0F C6 43  23 00 C6 43 1E 01 C6 43
1F 01 C6 43 5C 14 B8 (0A:19)  00 00 00 66 89 4B 21 E8
40 EA FF FF 98 6B C0 2E  0F B6 73 10 8A 84 06 90
7E 17 00 88 43 60 BA 27  00 00 00 8D 43 17 E8 0D
FA 0C 00 66 C7 43 5E 00  00 C6 43 5D 0A 5F 5E 59

}}}


{{{
int __fastcall INITSHIP_Load_Amoeba_Ship_Design_(int a1, int a2)
{
  __int16 v2; // cx@1
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  char v6; // al@2
  int v7; // eax@4
  int v8; // esi@4
  int result; // eax@6

  v3 = a1;
  struct_Clear_Structure_(a1, 99, a1, a2);
  v4 = v3;
  v5 = dword_18A66C;
  do
  {
    v6 = *(_BYTE *)v5++;
    *(_BYTE *)v4++ = v6;
  }
  while ( v6 );
  if ( v2 )
  {
    *(_BYTE *)(v3 + 16) = 3;//(hull type)
    *(_BYTE *)(v3 + 17) = 0;
    *(_BYTE *)(v3 + 18) = 0;
    *(_BYTE *)(v3 + 19) = INITSHIP_Best_Warp_Drive_(10);
    v8 = 46 * *(_BYTE *)(v3 + 19);
    *(_BYTE *)(v3 + 21) = 2;
    *(_BYTE *)(v3 + 22) = 0;
    *(_BYTE *)(v3 + 20) = 1;
    *(_WORD *)(v3 + 28) = 45;//Caustic Slime
    *(_BYTE *)(v3 + 32) = 15;
    *(_WORD *)(v3 + 33) = 0;
    *(_BYTE *)(v3 + 35) = 0;
    *(_BYTE *)(v3 + 30) = 2;
    *(_BYTE *)(v3 + 31) = 2;
    *(_WORD *)(v3 + 36) = 23;//Anti-Matter Bomb
    *(_BYTE *)(v3 + 40) = 15;//firing arc (360)
    *(_WORD *)(v3 + 41) = 0;
    *(_BYTE *)(v3 + 43) = 10;
    *(_BYTE *)(v3 + 38) = 5;
    *(_BYTE *)(v3 + 39) = 5;
    v7 = *(_BYTE *)(v3 + 16);
    *(_BYTE *)(v3 + 92) = 8;
  }
  else
  {
    *(_BYTE *)(v3 + 16) = 2;
    *(_BYTE *)(v3 + 17) = 0;
    *(_BYTE *)(v3 + 18) = 0;
    *(_BYTE *)(v3 + 21) = 2;
    *(_BYTE *)(v3 + 22) = 0;
    *(_BYTE *)(v3 + 19) = 0;
    *(_BYTE *)(v3 + 20) = 0;
    *(_WORD *)(v3 + 28) = 45;
    *(_BYTE *)(v3 + 32) = 15;
    *(_BYTE *)(v3 + 35) = 0;
    *(_BYTE *)(v3 + 30) = 1;
    *(_BYTE *)(v3 + 31) = 1;
    *(_BYTE *)(v3 + 92) = 20;
    *(_WORD *)(v3 + 33) = 0;
    v7 = 46 * (signed __int16)INITSHIP_Best_Warp_Drive_(10);
    v8 = *(_BYTE *)(v3 + 16);
  }
  *(_BYTE *)(v3 + 96) = *(&byte_177E90[v8] + v7);
  result = struct_Set_Bit_Field_(v3 + 23, 39);
  *(_WORD *)(v3 + 94) = 0;
  *(_BYTE *)(v3 + 93) = 10;
  return result;
}
}}}
crystal
{{{
one for all:
C6 43 11 00 C6 43 12 00  C6 43 15 05 66 85 C9 74

big:
C6 43 10 04 B8 0B 00 00  00 C6 43 16 00 E8 C4 E8
FF FF 88 43 13 0F B6 43  13 6B F0 2E C6 43 14 01
66 C7 43 1C 2A 00 C6 43  20 0F 66 C7 43 21 02 00
C6 43 23 00 C6 43 1E 01  C6 43 1F 01 66 C7 43 24
1A 00 C6 43 28 0F 66 C7  43 29 00 00 C6 43 2B 0A
C6 43 26 05 0F B6 43 10  C6 43 27 05 8A 84 06 90
7E 17 00 C6 43 5C 09 EB  61 C6 43 10 02 C6 43 16

small:
C6 43 10 02 C6 43 16 00  C6 43 13 00 C6 43 14 00
66 C7 43 1C 2A 00 C6 43  20 0F C6 43 23 00 C6 43
1E 01 C6 43 1F 01 66 C7  43 24 19 00 C6 43 28 0F
C6 43 2B 0A C6 43 26 05  C6 43 27 05 66 89 4B 21
B8 0B 00 00 00 66 89 4B  29 E8 1F E8 FF FF 98 6B
C0 2E 0F B6 73 10 8A 84  06 90 7E 17 00 C6 43 5C
15 88 43 60 66 C7 43 5E  00 00 C6 43 5D 0B 5F 5E

}}}
= crystal =

{{{

char __fastcall INITSHIP_Load_Crystal_Ship_Design_(int a1, int a2)
{
  __int16 v2; // cx@1
  int v3; // ebx@1
  int v4; // edi@1
  int v5; // esi@1
  char v6; // al@2
  char result; // al@4
  int v8; // esi@4
  int v9; // eax@4

  v3 = a1;
  struct_Clear_Structure_(a1, 99, a1, a2);
  v4 = v3;
  v5 = dword_18A670;
  do
  {
    v6 = *(_BYTE *)v5++;
    *(_BYTE *)v4++ = v6;
  }
  while ( v6 );
  *(_BYTE *)(v3 + 17) = 0;
  *(_BYTE *)(v3 + 18) = 0;
  *(_BYTE *)(v3 + 21) = 5;
  if ( v2 )
  {
    *(_BYTE *)(v3 + 16) = 4;
    *(_BYTE *)(v3 + 22) = 0;
    *(_BYTE *)(v3 + 19) = INITSHIP_Best_Warp_Drive_(11);
    v8 = 46 * *(_BYTE *)(v3 + 19);
    *(_BYTE *)(v3 + 20) = 1;
    *(_WORD *)(v3 + 28) = 42;
    *(_BYTE *)(v3 + 32) = 15;
    *(_WORD *)(v3 + 33) = 2;
    *(_BYTE *)(v3 + 35) = 0;
    *(_BYTE *)(v3 + 30) = 1;
    *(_BYTE *)(v3 + 31) = 1;
    *(_WORD *)(v3 + 36) = 26;
    *(_BYTE *)(v3 + 40) = 15;
    *(_WORD *)(v3 + 41) = 0;
    *(_BYTE *)(v3 + 43) = 10;
    *(_BYTE *)(v3 + 38) = 5;
    v9 = *(_BYTE *)(v3 + 16);
    *(_BYTE *)(v3 + 39) = 5;
    result = *(&byte_177E90[v8] + v9);
    *(_BYTE *)(v3 + 92) = 9;
  }
  else
  {
    *(_BYTE *)(v3 + 16) = 2;
    *(_BYTE *)(v3 + 22) = 0;
    *(_BYTE *)(v3 + 19) = 0;
    *(_BYTE *)(v3 + 20) = 0;
    *(_WORD *)(v3 + 28) = 42;
    *(_BYTE *)(v3 + 32) = 15;
    *(_BYTE *)(v3 + 35) = 0;
    *(_BYTE *)(v3 + 30) = 1;
    *(_BYTE *)(v3 + 31) = 1;
    *(_WORD *)(v3 + 36) = 25;
    *(_BYTE *)(v3 + 40) = 15;
    *(_BYTE *)(v3 + 43) = 10;
    *(_BYTE *)(v3 + 38) = 5;
    *(_BYTE *)(v3 + 39) = 5;
    *(_WORD *)(v3 + 33) = 0;
    *(_WORD *)(v3 + 41) = 0;
    result = *(&byte_177E90[46 * (signed __int16)INITSHIP_Best_Warp_Drive_(11)] + *(_BYTE *)(v3 + 16));
    *(_BYTE *)(v3 + 92) = 21;
  }
  *(_BYTE *)(v3 + 96) = result;
  *(_WORD *)(v3 + 94) = 0;
  *(_BYTE *)(v3 + 93) = 11;
  return result;
}


}}}
eel

= eel =
{{{
void __fastcall INITSHIP_Load_Eel_Ship_Design_(int a1, __int16 a2, int a3, int a4)
{
  int v4; // ebx@1
  int v5; // edi@1
  int v6; // esi@1
  char v7; // al@2
  char v8; // cl@4
  char v9; // al@4
  int v10; // ecx@4
  int v11; // esi@4
  int v12; // ecx@4
  __int16 v13; // [sp+0h] [bp-4h]@1

  v4 = a1;
  v13 = a2;
  struct_Clear_Structure_(a1, 99, a1, a4);
  v5 = v4;
  v6 = dword_18A678;
  do
  {
    v7 = *(_BYTE *)v6++;
    *(_BYTE *)v5++ = v7;
  }
  while ( v7 );
  *(_BYTE *)(v4 + 17) = 0;
  *(_BYTE *)(v4 + 18) = 0;
  *(_BYTE *)(v4 + 21) = 4;
  if ( v13 )
  {
    *(_BYTE *)(v4 + 16) = 3;
    v9 = INITSHIP_Best_Warp_Drive_(13);
    *(_BYTE *)(v4 + 22) = 0;
    *(_BYTE *)(v4 + 19) = v9;
    *(_BYTE *)(v4 + 20) = 1;
    struct_Set_Bit_Field_(v10, 19);
    v11 = 46 * *(_BYTE *)(v4 + 19);
    *(_WORD *)(v4 + 28) = 44;
    *(_BYTE *)(v4 + 32) = 15;
    *(_WORD *)(v4 + 33) = 0;
    *(_BYTE *)(v4 + 35) = 0;
    *(_BYTE *)(v4 + 30) = 2;
    v12 = *(_BYTE *)(v4 + 16);
    *(_BYTE *)(v4 + 31) = 2;
    v8 = *(&byte_177E90[v12] + v11) + 8;
    *(_BYTE *)(v4 + 92) = 11;
  }
  else
  {
    *(_BYTE *)(v4 + 16) = 2;
    *(_BYTE *)(v4 + 22) = 0;
    *(_BYTE *)(v4 + 19) = 0;
    *(_BYTE *)(v4 + 20) = 0;
    struct_Set_Bit_Field_(v4 + 23, 19);
    *(_WORD *)(v4 + 28) = 44;
    *(_BYTE *)(v4 + 32) = 15;
    *(_WORD *)(v4 + 33) = 0;
    *(_BYTE *)(v4 + 35) = 0;
    *(_BYTE *)(v4 + 30) = 1;
    *(_BYTE *)(v4 + 31) = 1;
    v8 = *(&byte_177E90[46 * (signed __int16)INITSHIP_Best_Warp_Drive_(13)] + *(_BYTE *)(v4 + 16)) + 8;
    *(_BYTE *)(v4 + 92) = 23;
  }
  *(_BYTE *)(v4 + 96) = v8;
  *(_WORD *)(v4 + 94) = 0;
  *(_BYTE *)(v4 + 93) = 13;
  JUMPOUT(*(unsigned int *)locret_56580);
}
}}}
= marauder =
{{{
      struct_Clear_Structure_(a1, 99, a1, a4);
      *(_DWORD *)v9 = *(_DWORD *)"Marauder";
      v9 += 4;
      *(_DWORD *)v9 = *(_DWORD *)&aMarauder[4];
      *(_BYTE *)(v9 + 4) = aMarauder[8];
      *(_BYTE *)(v5 + 17) = 0;
      *(_BYTE *)(v5 + 18) = 0;
      *(_BYTE *)(v5 + 21) = 5;
      *(_BYTE *)(v5 + 16) = 1;
      *(_BYTE *)(v5 + 22) = 6;
      *(_BYTE *)(v5 + 20) = 1;
      *(_BYTE *)(v5 + 19) = 5;
      *(_WORD *)(v5 + 28) = 4;
      *(_BYTE *)(v5 + 32) = 1;
      *(_WORD *)(v5 + 33) = 0;
      *(_BYTE *)(v5 + 35) = 0;
      *(_BYTE *)(v5 + 30) = 3;
      *(_BYTE *)(v5 + 31) = 3;
      *(_WORD *)(v5 + 36) = 4;
      *(_BYTE *)(v5 + 40) = 1;
      *(_WORD *)(v5 + 41) = 2;
      *(_BYTE *)(v5 + 43) = 0;
      *(_BYTE *)(v5 + 38) = 1;
      *(_BYTE *)(v5 + 39) = 1;
      *(_WORD *)(v5 + 44) = 24;
      *(_BYTE *)(v5 + 48) = 15;
      *(_WORD *)(v5 + 49) = 0;
      *(_BYTE *)(v5 + 51) = 10;
      *(_BYTE *)(v5 + 46) = 1;
      *(_BYTE *)(v5 + 47) = 1;
      struct_Set_Bit_Field_(v5 + 23, 7);
      struct_Set_Bit_Field_(v8, 24);
}}}

= BEST WARP DRIVE =

{{{
signed int __fastcall INITSHIP_Best_Warp_Drive_(__int16 a1)
{
  signed int result; // eax@1
  __int16 v2; // bx@1
  signed int v3; // edx@2

  v2 = a1;
  result = 0;
  if ( v2 >= 8 )
  {
    switch ( v2 )
    {
      case 8:
      case 12:
      case 13:
        result = 6;
        break;
      case 9:
      case 11:
        result = 4;
        break;
      case 10:
      case 14:
        result = 2;
        break;
      default:
        return result;
    }
  }

}}}